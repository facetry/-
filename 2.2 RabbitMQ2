
1.RabbitMQ主要有四种类型的交换器：

fanout：（会把消息发送到路由的所有队列）
扇形交换器，它会把发送到该交换器的消息路由到所有与该交换器绑定的队列中。如果使用扇形交换器，则不会匹配路由Key。
direct：（精确匹配）
direct交换器，会把消息路由到RoutingKey与BindingKey完全匹配的队列中
完全匹配BindingKey和RoutingKey的direct交换器有些时候并不能满足实际业务的需求。
topic：（模糊匹配）
类型的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定:

RoutingKey为一个点号"."分隔的字符串(被点号"."分隔开的每一段独立的字符串称为一个单词)，如"hs.rabbitmq.client"，"com.rabbit.client"等。
BindingKey和RoutingKey一样也是点号"."分隔的字符串；
BindingKey中可以存在两种特殊字符串"*"和"#"，用于做模糊匹配，其中"*"用于匹配一个单词，"#"用于匹配多规格单词(可以是零个)。

header：（用消息头的价值对和交换器绑定队列的键值对进行匹配---该交换器类型性能较差且不实用，因此一般不会用到。）
headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers (也是一个键值对的形式) ，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。

2. mandatory参数：

mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory参数设为true 时，如果交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用BasicReturn命令将消息返回给生产者；当mandatory 参数设置为false 时，则消息直接被丢弃。（生产者需要开一个回调的函数来处理不能路由到的消息）

3. 备份交换器：

备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息
备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。
备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型。

需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。

考虑这样一种情况，如果备份交换器的类型是direct，并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失；如果消息携带的路由键为key1，则可以存储到队列中。

对于备份交换器，有以下几种特殊情况：

如果设置的备份交换器不存在，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失；
如果备份交换器没有绑定任何队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失；
如果备份交换器没有任何匹配的队列，客户端和RabbitMQ服务端都不会有异常出现，此时消息会丢失；
如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。

4.设置消息过期时间TTL

目前有两种方法可以设置消息的TTL：
第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间；
(通过队列属性设置消息TTL的方法是在channel.QueueDeclare方法中加入x-message-ttl参数实现的，这个参数的单位是毫秒)
第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同
(针对每条消息设置TTL的方法是在channel.BasicPublish方法中加入Expiration的属性参数，单位为毫秒)
对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去；而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。
如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成“死信” (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)

5.死信队列
DLX(Dead-Letter-Exchange)是指死信交换器。当消息在一个队列中变成死信之后，它能重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就被称为死信队列。

消息变成死信主要有以下几种情况：
消息被拒绝(BasicReject/BasicNack) ，井且设置requeue参数为false；(消费者确认机制我们将会在下一篇文章中涉及)
消息过期；
队列达到最大长度。

DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何队列上被指定，实际上就是设置某个队列的属性。
当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。
通过在channel.QueueDeclare方法中设置x-dead-letter-exchange参数来为这个队列添加DLX
6.延迟队列
RabbitMQ本身并未提供延迟队列的功能。延迟队列是一个逻辑上的概念，可以通过过期时间+死信队列来模拟它的实现
生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了“生产者发布了消息，在过了n时间后消费者消费了消息”，起到了延迟消费的作用。
延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿，10s后补偿，5m后补偿......)。
7.优先级队列
优先级队列。队列中的消息会有优先级，优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事：
将队列声明为优先级队列，即在创建队列的时候添加参数x-max-priority指定最大的优先级，值为0-255（整数）。
为优先级消息添加优先级。
注意：
没有指定优先级的消息会将优先级以0对待。
对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。
对于相同优先级的消息，后进的排在前面。
8. RPC实现
RPC是Remote Procedure Call的简称，即远程过程调用。它是一种通过网络从远程计算机上请求服务，不需要了解底层网络的技术。RPC的主要功用是让构建分布式计算更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。

借助于BasicProperties的两个参数。
ReplyTo：通常用来设置一个回调队列。
CorrelationId：用来关联请求(request) 和其调用RPC之后的回复(response) 。

流程：
当客户端启动时，创建一个匿名的回调队列。
客户端为RPC请求设置2个属性：ReplyTo用来告知RPC服务端回复请求时的目的队列，即回调队列；Correlationld用来标记一个请求。
请求被发送到RpcQueue队列中。
RPC服务端监听RpcQueue队列中的请求，当请求到来时，服务端会处理并把带有结果的消息发送给客户端。接收的队列就是ReplyTo设定的回调队列。
客户端监听回调队列，当有消息时，检查Correlationld属性，如果与请求匹配，那就是结果了。
