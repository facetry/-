定义：redis是一个key-value存储系统,它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)
     和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，
     redis支持各种不同方式的排序。
     为了保证效率，数据都是缓存在内存中。
     区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
     支持多种语言
     Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。
     
1.redis写操作

Slot又称分表分库

对象保存到Redis之前先经过CRC16哈希到一个指定的Node上，例如Object4最终Hash到了Node1（redis的master结点）上
每个Node被平均分配了一个Slot段，对应着0-16384，Slot不能重复也不能缺失，否则会导致对象重复存储或无法存储。
Node之间也互相监听，一旦有Node退出或者加入，会按照Slot为单位做数据的迁移。例如Node1如果掉线了，0-5640这些Slot将会平均分摊到Node2和Node3上,
由于Node2和Node3本身维护的Slot还会在自己身上不会被重新分配，所以迁移过程中不会影响到5641-16384Slot段的使用

简单总结下哈希Slot的优缺点：
缺点：每个Node承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重
优点：将Redis的写操作分摊到了多个节点上，提高写的并发能力，扩容简单


2.redis的读操作

主从结点（Master Slaver）
1个Master，可以有N个slaver，而且Slaver也可以有自己的Slaver，由于这种主从的关系决定他们是在配置阶段就要指定他们的上下级关系，
而不是Zookeeper那种平行关系是自主推优出来的。
读写分离，Master只负责写和同步数据给Slaver，Slaver承担了被读的任务，所以Slaver的扩容只能提高读效率不能提高写效率.
Slaver先将Master那边获取到的信息压入磁盘，再load进内存，client端是从内存中读取信息的，所以Redis是内存数据库
当一个新的Slaver加入到这个集群时，会主动找Master来拜码头，Master发现新的小弟后将全量数据发送给新的Slaver，数据量越大性能消耗也就越大，
所以尽量避免在运行时做Slaver的扩容。

简单总结下主从模式的设计：
优点：读写分离，通过增加Slaver可以提高并发读的能力。
缺点：Master写能力是瓶颈。
         
虽然理论上对Slaver没有限制但是维护Slaver开销总将会变成瓶颈。
Master的Disk大小也将会成为整个Redis集群存储容量的瓶颈。


https://blog.csdn.net/yejingtao703/article/details/78484151




